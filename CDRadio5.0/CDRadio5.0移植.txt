******************************************************************************************************
时间：2018.3.38
----------------------------------
主题：指定移植的整体计划和执行策略
时间范围：
步骤：
第一步：搭建调试环境
  1）对应修改过的模块，应该单独调试，保证相同的输入情况下得到相同的输出
  2）需要搭建调试环境，利用串口输入输入信号
第二步：确定哪些文件是做过修改的
第三步：移植修改后的部分
第四步：测试
  1）基础功能测试
  2）测试新特性           3）测试遗留问题：是否存在稳定的错误状态；是否会进入HardFault；是否会出现无端复位；考虑模式切换的逻辑是否可以修改（是否无需软件复位就可以进行模式切换）
第五步：修复移植过程中的bug

问题一：
可以变过修改变测试吗？
：好像不行


******************************************************************************************************
时间：2018.4.2
----------------------------------
以下文件删除：
1、CSLink.c
2、DFE.C

如何去移植：
第一步：搭建测试环境
  1）需要一个干净的工程：
    1、可以实现单步调试
    2、接收串口传输文件
    
 难点1：之前为了加快运行速度，将很多模块都搬到ram去执行，如何将他们重新搬到flash。
 难点2：如何通过串口发送文件。以int或者特定的数据类型发送文件，而不是二进制数据流。
 
 总结：代码（中断向量表）在flash中执行还是在RAM中执行。---------------------难点1解决
 一、普通代码判断逻辑
 1、使用窗口设置的内存布局还是使用分散加载：魔术棒-》Linker->Use Memory layout from target dialog 
    勾选则选择窗口设置的内存布局，否则采用手动设置SCT文件进行加载
 2、使用窗口设置的内存布局
 第一步：魔术棒->Target->设置IROM1（FLASH）、IRAM1...的起始地址
 第二步：右键文件->Option for File...->Memory Assignment->Code/Const中选择第一步设置的分区
 3、分散加载
 需要手动编辑SCT文件
 
 二：中断向量表在FLASH中还是在RAW中
 第一种方式
 1、在system_MM32...中有一个条件编译
 #ifdef VECT_TAB_SRAM
  SCB->VCTOR=SRAM_BASE|VCTOR_TAB_OFFSET;
 #else
  ...
  意思个明确，如果定义了VECT_TAB_SRAM，中断向量表第一在SRAM，并且偏移量为VCTOR_TAB_OFFSET
2、魔术棒->C/C++->Define  VECT_TAB_SRAM
第二种方式：
在mian函数里面手动指定SCB->VTOR的指向


明天计划：
1、解决难点2，搭建完整测试环境
2、完成CDRadio.h的移植

******************************************************************************************************
时间：2018.4.3
----------------------------------
主题一：搭建完整测试环境---已完成
步骤一：串口传输文件并且直接输出
想法：串口接收和输出的都是字符串形式，所以问题的关键
  1）上位机如何把txt文件中的数据解析成一个个可以转换为数字的字符串（或者一个大的字符串）然后发送
  2）固件接收到上位机发送来的字符串后解析成数字，然后通过串口发送出去
  
  
******************************************************************************************************
时间：2018.4.3
----------------------------------
1、利用V1.4.1版本搭建测试环境，遇到无法触发串口中断问题，后经超哥指导，是因为在启动代码中没有注册中断的原因。（具体原因似懂非懂，暂时搞得不是很明白）



******************************************************************************************************
时间：2018.4.8
----------------------------------
计划：完成帧同步的移植
1、完成代码修改
2、测试代码

积累：MFC中路径用/

小结：今日已经完成帧同步移植
经验总结（以帧同步为例）：
1、首先对比5.0和4.1.4源码中关于帧同步部分的改动
2、要小心源码中全局变量，确定其值没有被改变
3、小心HandledPoint这个参数，在固件中这个参数的管理有点混乱
4、先使用打印输出语句
5、再使用单步调试


******************************************************************************************************
时间：2018.4.10
----------------------------------
1、开发测试用的上位机：可以输出指定长度的数据

关于内接收移植的测试：
1、内接收输出有问题
2、pilotRun的输出没问题
2、channelEst的输出有问题，怀疑是越界了
   确实是因为SymbolAvePower越界了（修改此参数之后依然有问题，看来是不仅仅因为如此）
   
******************************************************************************************************
时间：2018.4.11
---------------------------------- 

******************************************************************************************************
时间：2018.4.12
现存问题：
1、内接收的输出与算法不一致
2、ChannelEst的输出不一致，输入也不一致，相比VS板，会丢一些数据
分析：


******************************************************************************************************
时间：2018.4.15
问题：之前的测试结果是帧同步的输出完全吻合（当然运行的样本数据长度只是80000），但是很奇怪的现象是ChannelEst()函数输入不一样
分析：ChannelEst（）函数的输入理论上上只跟帧同步的输出相关，那么问题出现在哪儿？
1、很有可能是帧同步还有问题
主题一：回过头来确定帧同步是否完全一致
第一步：确定延迟相关的输入是否匹配，即case STATE_SYNC的输出
   
  
   
******************************************************************************************************
-------------------------------------
时间：2018.4.19
结论：FrmSynLock值没有问题



   
******************************************************************************************************
-------------------------------------
时间：2018.4.23
一、先解决输入数据问题，必须先确定输入数据是没有问题的（前50万数据）
1、输入数据长度为40万，直接在main中将串口接收到的数据输出
结果：
  1）不匹配
  2）看起来连续丢了6*256个数据（1529:148488-150017），其它数据没有问题
2、把串口2中断的AT指令处理去掉后，前40万数据一模一样
3、验证inner输入
   结论：前50万数据是完全可信的
二、解决帧同步输出
1、帧同步输出不一致（第275128后的数据不一致，之前没有问题）
2、延迟相关输出完全吻合

已经确保帧同步没有问题：延迟相关一致、中心对称一致、输出一致，HeaderOut输入没有问题

******************************************************************************************************
-------------------------------------
时间：2018.4.24
一、修改LinkParaInit和Reset后的测试，内接收输入认为是没有问题的（测试了30万点数据）
二、修改ChannelEst,观测channelEST的输出（测试了前50万数据）
1、检查了ScalingFactor，基本是一样的（小数点后三位可能差1）
2、channelresponse基本吻合，损失精度（FFT软件实现）
3、用硬件加速器测试，结果有误差，但是大体一致
结论：ChannelEst基本可信任
三、PilotOut修改，修改后结果初步观测相同